% Generated by word2x on 29th December, 1999
%
\date{29th December, 1999}
\documentclass{article}
\usepackage{amstext}
\def\reg{\setbox0\hbox{$\mathchar"20D$}%
\hbox to 0pt{\hbox to \wd0{\hfill\,\rm R\hfill}\hss}%
$\mathchar"20D$}
\usepackage[latin1]{inputenc}
\begin{document}


RAGARIS Project



DICOM Subsystem Technical Report



Eray Özkural



\section{st September, 1998}



Abstract



DICOM standard has been a main concern in the development of the Ragaris
PACS because of its prominence in medical imaging. In the early design
stages many alternatives have been considered and it has been decided that
an in house implementation suits the needs of our project better. The design
and implementation has undergone a long period of development and the
software modules are sufficiently operational at the time of writing. This
document describes various design issues and technical details of the
software that makes the RAGARIS applications DICOM compliant.



Introduction



Through many years of worldwide experience of digital medicine, a standard
known as DICOM has emerged. The standard is a thorough collection of
documents which determine many aspects of operation and communication of
devices which support digital imaging in medicine. It has been the de facto
industry standard for years and the most recent one is DICOM 3.0 that was
published by NEMA in 1997.



In brief, the standard directly addresses the communication, storage and
retrieval of medical imaging data, and other aspects of digital systems such
as a patient information system and printing. It is not the purpose of this
report to duplicate the numerous definitions and protocols of the DICOM
standard in this document. Rather, the reader is encouraged to refer to the
standard itself. Though lengthy, many of the main issues are to be best
found in the 14 parts of the standard. The emphasis of this document is on
our design and implementation of DICOM 3.0.



The standard is based on an object oriented information model to be able to
account for the conceptual depth and flexibility required by a medical
imaging system. The message passing (over TCP/IP), distributed, persistent
object system makes realization of a versatile and sizable PACS possible.
Once dealt appropriately DICOM makes things easier. However, DICOM itself is
fairly big: the current implementation supports the 24*5 primitive data
types (see PS3.5), 895 attribute types (see PS3.6), 103 information module
classes, 35 information object classes (composite and normalized, see PS3.3)
and 25 messages (see PS3.7). Obviously, DICOM represents many technical
challenges caused by its sheer complexity. Clear design directions had to be
taken, and most features of the standard have been successfully implemented.



This report describes the library by first elucidating the design issues,
then giving an overview of main library components and supplying a class
reference at a medium level of detail which furnishes insight into the
implementation.





Design Background



A major standard is usually prepared in terms of existing systems and
standards. DICOM is no exception; it leans on concepts from object-oriented
systems (IOD, services), databases (E-R diagrams), networked environments
(Application Entity, Association, Transfer Syntax); also it incorporates
many international standards by ISO, ANSI and IEEE\@. Nevertheless, the
standard introduces several proprietary terms and concepts which are
specific to DICOM, and in many cases, it is hard to tell which design would
be better since the standard avoids giving such an advice.



Therefore, the implementations led by development teams elsewhere have
followed quite different designs. For instance, an implementation works with
run-time classes, and interesting functions to manipulate objects of those
classes and send/receive messages. Another implementation keeps attribute
types in a database, and queries the database for type checking. These may
look clumsy, but if you need to know just one value from an object, you can
perhaps parse it with a simple code (so that it would skip all irrelevant
data) and fetch what you need. In particular, it is relatively easy to
implement a very small portion of the standard; but whenever one attempts at
a general solution, many hazards appear.







The implementation platform is already set as Windows NT / Microsoft Visual
C++, so our software has to respect the selection. As an object oriented
language, C++ is a suitable candidate for a DICOM implementation. Our
software, simply named DCL (DICOM Class Library), is designed to be close to
ANSI C++, bearing as little dependency on VC++ as possible. Development
followed an iterative development cycle: not all features explained were
apparent at the first iteration (including the name of the software
library).





Library Overview



Pieces and Ties



DCL is composed of three parts: a base library which defines DICOM data
structures, a kernel library which provides core DICOM functionality and an
MFC extension that makes use of MFC for thread and socket support.



DCL Base - Class Generator



The first problem was the number of SOP Classes (see PS3.4) in DICOM\@. There
are so many data structures with complex data types that it is almost
impossible to code them in C++ in a straightforward manner. Instead, one
must manage the structures slightly differently. There are really two
choices: either one may write a run-time class system or generate
compile-time classes. Using an auxiliary run-time class system is partly
discarding the benefits of an object-oriented language, in this case C++.
Furthermore, using the MFC run-time class system does not make things
easier. It is not a matter of efficiency but rather a matter of
comprehensibility and reliability that forced us to choose a compile-time
system. Then, a compiler has to be written. The Class Generator compiled our
versions of the long data sheets of the standard into many appropriate C++
classes. These classes are generated at the aggregate level, utilizing the
interface of primitive data types and basic encoding and decoding schemes.
By proper object oriented design, one may define the interface prior to any
programming: we have followed the same method by writing a compiler that
generates such classes prior to implementation of core DICOM functionality.
This method has also assisted us in determining what basic functionality is
ever required.



The major use of this approach was that the system was flexible, efficient,
understandable and reliable. The system proved to be flexible because adding
or removing a class or attribute was no burden. One could augment the class
system as quick as he could read it. Efficiency comes from the ability to
make use of built-in static C++ mechanisms such as inheritance instead of
implementing a custom one. The system was comprehensible because the adapted
classes were, in the interface, no worse than a typical C++ class; the DICOM
information model was translated at exactly the same level that it was
intended. Surely, reliability is a result of moving some operations like
type checking to compile-time; then, one can be sure that he is accessing
the right data type. Adapted classes, combined with a persistence mechanism,
is suitable for implementing DICOM SOP classes.



The output C++ code has classes named after information modules and IOD{'}s.
A top level class contains attributes (with their types denoting their Value
Representation and Value Multiplicity, see PS3.5), selector and modifier
methods, string representation methods, and availability checking methods
for each attribute, nested Coder classes with all Transfer Syntaxes
supported. An IOD inherits from abstract super classes of its modules. The
IODs do not just aggregate the attributes from their modules, but inherit
their abstract interfaces. Also, sub-level classes were generated to be able
to implement the nested sequences (described in PS3.5). In addition to this,
the compiler handles mutually exclusive modules and DICOM pointer types. We
have made use of genericity features of C++, as well. The template mechanism
enables better setting of some of the key abstractions. We would like to
explain some of the abstractions at this stage. {`}VR{'} denotes a Value
Representation name such as US or AT in the following definitions.



Coder<class TS> classes: These classes are responsible for the encoding of
an adapted DICOM\@ class with a transfer syntax denoted by TS. They are
embedded within the class which they encode.



VRVR with Value Multiplicity 1

VRf<int arity> VR with a fixed Value Multiplicity of {`}arity{'} (ex. 3)

VRr<int lower, int upper> VR with a Value Multiplicity in the range of
{`}lower{'}-{`}upper{'}

(ex. 1-10)

VRvVR with a variable Value Multiplicity (1-N)

VReVR with an even variable Value Multiplicity (1-2N)

Seq<class SQ>Nested Sequence of sub-class SQ



The generated classes make use of standard C++ library for ease of use and
efficiency. Specifically, the boolean vectors Coders use are template
specialization vector<bool> classes.



Note that these classes are not declared within the generated code, but in
the other modules. The generated code is only a client of these classes. The
C++ programs are then compiled into a library module called DCL Base.



DCL Kernel



For all these things to be operational, the complementary software should be
written., and the required module is named DCL Kernel. The Kernel module
must be thought in two modes (the question why they are not cleanly separate
remains open): Kernel Auto Generation Interface and Kernel Interface, with
the former defining the semantics required to compile auto generated classes
and the latter the whole interface.



Kernel Auto Generation Interface defines the following important classes as
well as those defined in the previous section.



Tag: A 4 bytes tag which is unique for each attribute (see PS3.5). Also
attributes are ordered by increasing tag number within a dataset when
encoded.



DStream: Base class for DICOM Streams. Descendants of this class manage
streaming over TCP/IP and disk files.



TransferSyntax: Base class for transfer syntax classes. The transfer syntax
classes are static classes which supply low-level methods for data encoding
and decoding. Each transfer syntax class handles these tasks differently.
Currently, Implicit VR Little Endian, Explicit VR Little Endian, Explicit VR
Big Endian transfer syntaxes are in use. It would be no matter to augment
the remaining Transfer Syntaxes



SOP: Abstract base class of all SOP Classes, this abstract class defines the
minimal interface an SOP should support such as construction, destruction
and encoding/decoding.



DPtr: A pointer with a dynamic type that refers to an SOP instance. The DPtr
can check the virtual memory system to see if the instance really exists or
dereference.



The remaining of Kernel Interface features:



DException: Base class for all DICOM Exceptions. Exceptions are thrown by
many mechanisms in the system, for instance when a protocol error occurs.
The DException has many subclasses which indicate different kinds of errors.
The DCL user can catch and assess these errors.



DStreamBuffer: A stream buffer which implements DStream interface. This
buffer is appropriate for PDU/PDV style input/output.



DBinaryFileStream: A subclass of DStream which reads and writes to regular
files.



DTCPStream: A subclass of DStream which handles client stream connections
over TCP.



DServerStream: A special subclass of DTCPStream which is better suited for
server connections.



DApplication: This is the abstraction of a DICOM Application Entity. It is
responsible for managing various configuration parameters and maintaining
system data. There is only one instance of DApplication called dicom{\_}app
in an application program.



StorageManager: A class which implements a simple minded virtual memory
scheme for large objects.



DContext: The abstraction for a DICOM association, a subclass of DContext
which manages execution of DICOM services.



DTCPContext: Subclass of DContext which supervises both client and server
association, and handling of DIMSE-C and DIMSE-N services within that
association.



DFileContext: Subclass of DContext responsible for reading and writing DICOM
files. This class implements a tentative subset of DICOM File Services



DImageStacker: This class is declared if DCL{\_}ARCHIVE symbol is defined.
The class checks to see if a series is complete and if so sends a special
message to the archive system.



Within the DCL Kernel, Microsoft specific features are kept minimum and ANSI
C++ library is used for all elementary data structures; list<T>, vector<T>,
map<K,T> are used extensively.



DCL MFC Kernel



This part of DCL is MFC specific. The following definitions give an
overview.



CListenerSocket: Subclass of CSocket that listens to the DICOM port of AE
all the time spawning children server connections appropriately.



CListenerThread: dicom{\_}app started thread which initiates the DICOM SCP.



CCustomSocket: Subclass of CSocket which is capable of processing PDUs.



CClientSocket: Subclass of CCustomSocket which is intended for client
connections, sends a message to calling thread on end of transmission.



CClientThread: Thread that is started when a client connection is going
underway.



CServerSocket: Subclass of CCustomSocket which is intended for server
connections. On receipt of a PDU it executes its DTCPContext which is in
server mode.



CServerThread: Thread that is started when a new server connection is made.



CCTEmulator: A dialog which essentially emulates a CT machine that C-STOREs
on a host AE.







DCL Reference





Overview



In the following sections, specifications of classes in DCL are presented.
The specification includes naming, synopsis, hierarchy and interface
definitions of each relevant class, together with a brief explanation of the
implementation. First, the general specification of Class Generator output
is given, thus a description of DCL Base can be made. Then, the classes in
DCL Kernel, and DCL Kernel MFC are specified. Meta Symbols when required are
enclosed in braces as in {\{}MetaSymbol{\}}. The reader must note that the
specifications are at the medium level, not every internal method or
component is illustrated, neither only public interface is stated.







DCL Base - Class Reference



The Class Generator creates adapted classes for DICOM data structures
according to a simple set of rules. This section gives a general
specification of Module, IOD, and Message classes generated by the compiler.



Common Features -- DataSet Implementation



Module, IOD and Module classes are DICOM datasets, though they are very
similar. The common features given apply to all three of them.




Name: {\{
}DataSet{
\}}



Synopsis: DICOM Dataset which aggregates a set of Attributes each of which
entail an Attribute Tag, an Attribute Name, a Value Representation and a
Value Multiplicity.



Super Classes: Depends on type



Components:



each attribute has a counterpart in {\{}DataSet{\}} with an auto generated
name, these are declared private and are inaccessible.



typedef {\{}VRVM{\}} {\{}Attribute{\}}{\_}t type declaration for sequential
attributes of ones with Value Multiplicity greater than 1.



class Coder<class TS>: A {\{}DataSetCoder{\}} is responsible for decoding
and encoding of the parent {\{}DataSet{\}}



Interface:



The {\{}Attribute{\}} symbol may be substituted with any DICOM Attribute
Name of the {\{}DataSet{\}}

{\{}VRVM{\}} is the datatype of {\{}Attribute{\}} that is a combination of
its VR and VM.



const {\{}VRVM{\}} sel{\{}Attribute{\}}() returns the value of
{\{}Attribute{\}} attribute if present, default value of {\{}VRVM{\}}
otherwise.



void mod{\{}Attribute{\}}({\{}VRVM{\}}) replaces the value of {\{}VRVM{\}}
with the supplied value. The IOD is notified of modification.



const {\{}VRVM{\}}{\&} ref{\{}Attribute{\}}() returns a reference to
{\{}Attribute{\}}, present if VR is sequential or VM is greater than 1.



bool avl{\{}Attribute{\}}() informs affirmative if {\{}Attribute{\}} is
present in {\{}DataSet{\}}



string str{\{}Attribute{\}}() returns string representation of
{\{}Attribute{\}}



string toString() returns a string representation of the whole dataset



Description:The attributes are arranged as instance variables with auto
generated names, actually there are two kinds of attributes : normal
attributes, and pointer attributes. DICOM typed pointers are recognized and
implemented separately by the compiler.





Name: {\{}DataSetCoder{\}}



Interface:



{\{}DataSet{\}} is the parent dataset,



void decode(DStream{\&}, {\{}DataSet{\}}{\&}) destructively decodes the
stream in the given dataset



void encode(DStream{\&}, {\{}DataSet{\}}{\&}) encodes the dataset to the
stream





Description: The {\{}DataSetCoder{\}} is a template class which may be
instantiated with any desired TransferSyntax class which must implement a
host of static decoding/encoding primitive methods. The implementation is
subtler than it seems, when the class is created, the particular template
instantiations are also managed. The decode/encode methods are non trivial.
Type requirements and attribute collisions are handled appropriately, and
the encoding order is implicitly imposed on the decoding scheme. In brief,
the encode/decode methods are sequences of primitive coder operations from
{\{}VRVM{\}} classes.





Module, IOD and Message Classes



{\{}Module{\}} is a module, e.g. FrameOfReference.

{\{}IOD{\}} is an IOD, e.g. CTImage

{\{}Message{\}} is a message, e.g. CStoreRQ



These classes are specializations of {\{}DataSet{\}}, however no inheritance
relation is present since there is a genericity mechanism employed by the
compiler instead of inheritance.



Name: {\{}Module{\}}Mod



Synopsis: Represents a DICOM Information Module



Super Classes: Abstract{\{}Module{\}}Mod which is the abstract interface for
appropriate methods





Name: Abstract{\{}Attribute{\}}Mod



Synopsis: Abstract DICOM Module



Super Classes: None



Interface:



The {\{}Attribute{\}} symbol may be substituted with any DICOM Attribute
Name of the {\{}DataSet{\}}

{\{}VRVM{\}} is the datatype of {\{}Attribute{\}} that is a combination of
its VR and VM.



virtual const {\{}VRVM{\}} sel{\{}Attribute{\}}() = 0 returns the value of
{\{}Attribute{\}} attribute if present, default value of {\{}VRVM{\}}
otherwise.



virtual void mod{\{}Attribute{\}}({\{}VRVM{\}})=0 replaces the value of
{\{}VRVM{\}} with the supplied value. The IOD is notified of modification.



virtual bool avl{\{}Attribute{\}}()=0 informs affirmative if
{\{}Attribute{\}} is present in {\{}DataSet{\}}



string str{\{}Attribute{\}}() returns string representation of
{\{}Attribute{\}}



string toString() returns a string representation of the whole dataset





Name: {\{}IOD{\}}IOD



Synopsis: Represents a DICOM Information Object Definition



Super Classes: Abstract{\{}Module{\}}Mod where {\{}Module{\}} is one of the
modules the IOD contains.



Description: IOD inherits from all modules it has attributes of, so it
possesses as many interfaces, this provides the application programmer with
great flexibility. Duplicate attributes are handled so that the duplication
is totally transparent to the programmer.





Name: {\{}Message{\}}Msg



Synopsis: Represents a DICOM Command Set



Super Classes: None



Description: This is a plain command set, usually small.







DCL Kernel Auto Generation -Class Reference



Name: Tag



Synopsis: DICOM Attribute Tag



Components:



short group group number



short element element number



Interface:



Tag(short, short) constructor which inits group and element respectively



int number() returns a concatenated integer number



string toString()





Name: DStreamBase, alias DStream



Synopsis: Base class for all stream oriented classes in DCL



Components:



enum OpenMode : input, output



int position position in bytes wrt start position



Tag tag the tag buffer, the last tag read from the stream is stored here



Interface:



DStreamBase(OpenMode {\_}mode) constructs stream with openmode {\_}mode



virtual void read (char* buffer, int len) makes post processing for reading
len bytes into buffer



virtual void write (char* buffer, int len) makes post processing for writing
len bytes from buffer



void new{\_}tag(Tag t) informs that a new tag is in



bool valid{\_}tag() tells if the tag is valid



void invalidate{\_}tag() makes the tag invalid



Description: Provides base functionality for all DCL streams which are
capable of coding DICOM data sets. The tag buffer enables Transfer Syntax
clients to do processing without rewinding, since it is just 4 bytes we put
an auxiliary mechanism. This is the basic stream class, the actual ones are
derived from this class. The derived classes override read and write
methods, and call the ones in base class for post processing





Each {\{}TransferSyntax{\}} must conform to the following specification



Name: {\{}TransferSyntax{\}}



Synopsis: Abstraction for a DICOM Transfer Syntax



Components:



static UI UID UID for Transfer Syntax



enum IgnoreType : group{\_}length, private{\_}elt, unspecified



Interface:



static Tag decode{\_}tag(DStream {\&}d)



static void ignore{\_}elt(DStream{\&} d, IgnoreType mode = unspecified )

ignore an element with an ignorance type



static bool check{\_}data{\_}elt{\_}header(DStream{\&} d, const Attribute
{\&} a)

check if data element is present



static int decode{\_}req{\_}data{\_}elt{\_}header(DStream{\&} d, const
Attribute {\&} a)

decode an optional data element header, returns length of data field



static int decode{\_}opt{\_}data{\_}elt{\_}header(DStream{\&} d, const
Attribute {\&} a)



static void encode{\_}data{\_}elt{\_}header(DStream{\&} d, const Attribute
{\&} a)

encode a data element header with null value field



static void encode{\_}data{\_}elt{\_}header(DStream{\&} d, const Attribute
{\&} a, int del)



static int decode{\_}item{\_}header(DStream{\&} d) decode an item header



static bool is{\_}seq{\_}delim(DStream {\&} d) decode delimiter



static bool decode{\_}seq{\_}delim(DStream {\&} d)



static bool decode{\_}item{\_}delim(DStream {\&} d)



static void encode{\_}item{\_}header(DStream{\&} d) encode an item header



static void encode{\_}seq{\_}delim(DStream {\&} d) encode delimiter



static void encode{\_}item{\_}delim(DStream {\&} d)



static char decode{\_}char(DStream{\&} d)



static short decode{\_}short(DStream{\&} d)



static long decode{\_}long(DStream{\&} d)



static float decode{\_}float(DStream{\&} d)



static double decode{\_}double(DStream{\&} d)



static void decode{\_}binary(DStream{\&} d, char{\&} a)



static void decode{\_}binary(DStream{\&} d, short{\&} a)



static void decode{\_}binary(DStream{\&} d, long{\&} a)



static void decode{\_}binary(DStream{\&} d, unsigned char{\&} a)



static void decode{\_}binary(DStream{\&} d, unsigned short{\&} a)



static void decode{\_}binary(DStream{\&} d, unsigned long{\&} a)



static void decode{\_}binary(DStream{\&} d, float{\&} a)



static void decode{\_}binary(DStream{\&} d, double{\&} a)



static void decode{\_}string(DStream{\&} d, string {\&}str, int n)



static int decode{\_}delimited{\_}string(DStream{\&} d, string {\&}str, int
n)

decode a delimited character string of maximum n bytes, return number of
bytes decoded



static void encode{\_}char(DStream{\&} d, char a)



static void encode{\_}short(DStream{\&} d, short a)



static void encode{\_}long(DStream{\&} d, long a)



static void encode{\_}float(DStream{\&} d, float a)



static void encode{\_}double(DStream{\&} d, double a)



static void encode{\_}binary(DStream{\&} d, char{\&} a)



static void encode{\_}binary(DStream{\&} d, short{\&} a)



static void encode{\_}binary(DStream{\&} d, long{\&} a)



static void encode{\_}binary(DStream{\&} d, unsigned char{\&} a)



static void encode{\_}binary(DStream{\&} d, unsigned short{\&} a)



static void encode{\_}binary(DStream{\&} d, unsigned long{\&} a)



static void encode{\_}binary(DStream{\&} d, float{\&} a)



static void encode{\_}binary(DStream{\&} d, double{\&} a)



static void encode{\_}string(DStream{\&} d, string {\&}str, int n)



Description: This fat interface is used by the coder methods. However, they
must be somewhat self-explanatory





VR Classes



These specifications apply to all VR classes



{\{}VR{\}} is a VR with single VM

{\{}VR{\}} is a VR with a VM > 1



Name: {\{}VR{\}}



Synopsis: Value Representation Single Value Multiplicity



Super Classes: GenericStringVR<\unskip\ldots>, or
BinaryStringVR<\unskip\ldots> [ not documented ]



Components:



class Coder<class TS> a nested {\{}VRCoder{\}} class



Interface:



constructors: constructors vary, for string VR{'}s there are default string
constructors and for binary VR{'}s there are (e.g short for SS) binary
constructors suited to representation type. What is more, there are custom
constructors for some string VR{'}s. (e.g a constructor which takes year,
month and day for DA)



operator * returns a meaningful value for the VR



string toString() generates a string representation



Description:These classes are derived from big template classes





Name: {\{}VRMulti{\}}



Synopsis:VR with multiple VM



Super Classes: StringVRm<\unskip\ldots> or BinaryVRm<\unskip\ldots> [ not
documented]



Components:



class Coder<class TS> a nested {\{}VRCoder{\}} class



Interface: since generic multiple VM Value Representation classes are
derived from vector<T>, many convenient array operations are available.
However, it would be meaningless to apply every algorithm, since there is no
comparison defined.



Description: Multiple VM VR{'}s are implemented with the standard C++
library, thus are convenient and efficient.



Name: {\{}VRCoder{\}}



Synopsis: Coder of a Value Representation



Interface:



void decode{\_}mandatory(DStream{\&} d, Self {\&} a, const Attribute {\&}
attr{\_}info) decodes a type 1 attribute



bool decode{\_}required(DStream{\&} d, Self{\&} a, const Attribute{\&}
attr{\_}info) decodes a type 2 attribute, returns true if successful



bool decode{\_}optional(DStream{\&} d, Self{\&} a, const Attribute{\&}
attr{\_}info) decodes a type 3 attribute, returns true if successful



void encode{\_}empty(DStream{\&} d, Self{\&} a, const Attribute{\&}
attr{\_}info) encodes an empty attribute



void encode(DStream{\&} d, Self{\&} a, const Attribute{\&} attr{\_}info)
encodes the attribute





Description: The Coder class enables the {\{}DataSet{\}} to decode / encode
and specify requirement types of coding.



Sequential VR{'}s

Seq<\unskip\ldots>, OW, OB classes are not much different from the VR
specifications in the preceding paragraph. They apply in most part.



Name: DPtr



Synopsis: SOP instance pointer



Components:



UI class{\_}id indicates type of referred SOP instance

UI instance{\_}id identifies the instance



Interface:



DPtr(const UI{\&} a, const UI{\&} b) initializes the two UI components



SOP {\&} operator *() dereferences the persistent object that the pointer
references



SOP {\&} operator ->() same as previous



bool exists() checks if the system currently possesses the referenced object



Description: The persistent object pointer works in collaboration with
dicom{\_}app; the DApplication class and its StorageManager component embody
all necessary information about DICOM classes and instances. If the object
is not in memory the dereference operation loads the instance into memory,
which activates the object swapping mechanism in StorageManager.



Name: SOP



Synopsis: Abstract Base class for SOP Classes



Components:



bool protocol determines whether the object is a prototype



Interface:



SOP(bool pt) determines if the object a prototype



virtual SOP {\&} gen() = 0 allocates a persistent instance



virtual SOP {\&} gen(const UI{\&}) = 0 allocates a persistent instance with
specified instance UID



DPtr ptr() returns a persistent object pointer to the instance.



virtual const UI {\&} sel{\_}class{\_}id() = 0 selects class UID



virtual const UI {\&} sel{\_}instance{\_}id() = 0 selects instance UID



virtual void mod{\_}instance{\_}id(const UI {\&}) = 0 modify instance UID



virtual void decode(DStream {\&}d, UI ts{\_}uid) throw (DException) = 0
decodes object from d with a given Transfer Syntax UID



virtual void encode(DStream {\&}d, UI ts{\_}uid) throw (DException) = 0
decodes object to d with a given Transfer Syntax UID



virtual string toString() = 0 generates a string representation of SOP
instance



Description: A useful abstract interface to SOP Classes. By this class it is
fairly easy to implement SOP Classes







DCL Kernel - Class Reference



Name: DException



Synopsis: Base Class for DCL Exceptions



Components:



string reason brief explanation for exception





Interface:

DException(char *s) exception with reason s



DException(string s) exception with reason s



void why() reports reason of exception



Description: This class has many subclasses, reader can check them from the
DException.hxx header file. Each subclass is associated with a different
type of malfunction.





Name: DApplication



Synopsis: DICOM Application



Components:



SOPs sops map of prototypes of SOP Classes

StorageManager storage{\_}manager Persistent Object Storage Manager

UI implementation{\_}uid DICOM Implementation UID

SH implementation{\_}version{\_}name DICOM implementation name

AE ae{\_}title Application Entity Title

int dicom{\_}port DICOM port

map<AE, DAEInfo> address{\_}book application entity table

string uid{\_}org{\_}root used for UID generation

string serial{\_}number used for UID generation

string uid{\_}suffix used for UID generation

CListenerThread* listening{\_}thread DICOM SCP server





Interface:



void init{\_}class() initialize class



void read{\_}config() read configuration files



Description: Corresponds to a DICOM Application Entity. Holds many
parameters about the DICOM AE, and starts the SCP server as well as
initialization of SOP support.



Name: DTCPContext



Synopsis: SCU DContext over TCP



Super Classes: DContext



Components:



enum Mode: client, server operation mode



Interface:



DTCPContext(Mode) construct a TCP Context with requested operation mode



void associate(const char* calledAE) establish association with an
Application Entity



void release() release association



void cstore(SOP{\&} sop) perform C-STORE on called AE



UI{\&} ncreate(UI{\&} class) perform N-CREATE on called AE



void nset(UI{\&} ui, SOP{\&} sop) perform N-SET on called AE



void serve(CServerSocket {\&}) main SCP routine, below are specific server
routines



void serve{\_}associate();



void serve{\_}release();



void serve{\_}cstore();



void serve{\_}ncreate();



void serve{\_}nset();



Description: Handles all associations over the TCP, and SCU and SCP
processing of DICOM Services. Has an associated state with it, and conforms
to the DICOM Protocol Machine.





Name: DFileContext



Synopsis: DContext which works on DICOM disk file format.



Super Classes: DContext



Interface:



DFileContext(string {\&} s) open file context on specified file



SOP{\&} read() construct and return a new SOP instance as read from
associated file



void write(SOP{\&}) write an SOP instance into the associated file



void write(const UI{\&} class{\_}uid, const UI{\&} instance{\_}uid,

char* image, int image{\_}length) dump binary image



void read{\_}header(DStream {\&} stream, DFileHeader{\&} header) read DICOM
File Header



void write{\_}header(DStream {\&} stream, DFileHeader{\&} header) write
DICOM File Header



Description: This class is intended for working with DICOM files.
Internally, the DCL stores files in this format rather than a plain binary
image, because the header contains some auxiliary useful information



DCL Kernel MFC - Class Reference



The classes in Kernel MFC are tiny, thus require little need for reference.
Please refer to the library overview.



Name: CDICOMConsole



Synopsis: Console that reports DICOM events and errors.



Description: This is a convenient way of tracking the DICOM operations from
the application. Like the Java console found in some web browsers, the DICOM
console is the standard output of DCL system.





Name: CCTEmulator



Synopsis: A Dialog which emulates operation of a CT modality that does
C-STORE{'}s.



Super Classes: CDialog



Interface:



Called AE: Determines which Application Entity to establish an association.



Connect: Establish association.



Disconnect: Release association.



C-STORE: C-STORE{'}s designated DICOM files on the association.



Description: The CT Emulator establishes an association and sends several
images, preferably elements of a Series, to a host application entity. This
class is set up for demonstration purposes, the emulator is utilized by
sending a Series to our Archive.







DCL User Protocol



The application programmer adheres to some conventions to assure DICOM
compliance. The user is committed to the deployment of SCU only, the SCP is
handled automatically by the DCL system.



Client programming is straightforward, since the DCL does not support
asynchronous operation. Calls to DICOM services do not return until
completion or error occurrence. Generally, the user works on the SOP
instances, and applies DICOM services over Context classes. Currently, two
Context classes are supported, first of which is DTCPContext and second is
DFileContext.



With DTCPContext, the user first establishes an association with a SCP
Application Entity; then, the programmer performs any number of DICOM
services with the peer AE\@. Fatal errors cause exceptions to be thrown; it is
advisable that the programmer handles exceptions. After all operations
cease, the DCL user closes the connection by releasing the association. On
the other hand, with the DFileContext, the user can read and write single
DICOM files. Note that the DICOM directory structure is not yet implemented.





Notes to Developer



One should contemplate the structure of DCL in eloquent fashion when he
wishes to improve it. The following sections depict a developer{'}s account
of the library.



Sketch Board



The DCL is the result of our vision of a robust system that employs DICOM,
therefore the library has not been pictured as a black box which supports
some of the standard but rather as an animate company to it. The
architecture naturally exposes some deficiencies, however it is our belief
that they can be remedied with little labor. The developer must reckon that
the object-oriented design should be maintained, with the class semantics
closely paralleling that of concepts in the standard. Whenever the rational
connections dissolve into daily fixes, the library must be revised. We have
considered that the primary issue is to facilitate the making of DICOM
compliant application programs: the conformance of the library is not
sufficient by itself. Then, the features that an application programmer
anticipates should be in the library. One implication of this statement is a
rule of minimal usage, the application programmer expects to give only the
required information to a subsystem, that is he wishes to confront a slim
interface, with the chance of selecting beyond default modes of operation.



As seen in some example code fragments in the DICOM documents, a programmer
wants to open an association, command some DICOM messages sequentially , and
shut it down; besides there is a high contingency that he would like to
direct the objects in a smooth fashion. We concede then, that the programmer
must be able to perform all these tasks simply and efficiently. The DCL is
adjusted towards making common operations easier while allowing fancier
ones. We have first concentrated on the object system, inheritance
relations, abstract classes and methods, information retrieval and
manipulation, then moved on to decoding/encoding, message passing and
application framework, always taking these aspects of design into account.





How to Start a DCL Application



There is an example in the source tree which demonstrates how to use the DCL
for implementing a DICOM Application Entity. The project is called
DicomExampleApp.



To get going, the project settings and the source files must be configured
so that



+ The application uses MFC as a shared library, and has WinSock support



+ Exception handling and RTTI is enabled



+ Runtime library set as MultiThreaded DLL (debug - for Debug release)



+ The include paths ../dcl-kernel/src, ../kernel mfc lib/src, ../dcl-gen are
specified



+ The libraries ../lib/dcl-kernel.lib, ../lib/dcl-kernel-mfc.lib,
../dcl-base.lib are specified



+ The preprocesor directive



{\#}include <DCL.hxx>



is specified in all C++ source files which refer to the libraries.



+ The application initializes the DICOM subsytem by calling



dicom{\_}app.init{\_}class();



as the last suitable statement of InitInstance() method of your main
application class derived from CWinApp.



+ The following preprocessor directive is present in your '.rc2' script



{\#}include "../kernel mfc lib/DCL Resources.rc"



+ The application runs in the ../dist directory in order to access the
configuration and storage

files



Under compliance with these conditions, your application should compile
successfully.



Optionally, you are recommended the following:



+ In order to improve the build time, append the following include directive
to the StdAfx.h file



{\#}include <DCL.hxx>



+ Inserting the compiler directive



{\#}pragma warning(disable:4804)



in your StdAfx.h will provide cleaner builds



+ You can control the dicom console as in the following code fragment (which
is typical of menu event handlers)



void CDCLApplicationView::OnViewDicomConsole()

{\{}

CMenu* menu = AfxGetMainWnd()->GetMenu();



if (menu->GetMenuState(ID{\_}VIEW{\_}DICOM{\_}CONSOLE, MF{\_}BYCOMMAND) {\&}
MF{\_}CHECKED) {\{}

dicom{\_}app.hide{\_}console();

menu->CheckMenuItem(ID{\_}VIEW{\_}DICOM{\_}CONSOLE, MF{\_}UNCHECKED);

{\}} else {\{}

dicom{\_}app.show{\_}console();

menu->CheckMenuItem(ID{\_}VIEW{\_}DICOM{\_}CONSOLE, MF{\_}CHECKED);

{\}}

{\}}



+ The CT Emulator is a dialog which emulates the C-STORE operations
conducted by a CT machine.

You can use the CCTEmulator class (derived from CDialog) either as modal or
not.







Configuration Files



DCL, by default, checks some configuration files in the directory it is run
in. The distribution directory must therefore populate some tiny text files
within the ./etc directory to successfully open the library



ae-config.txt: file contains three words, name of the application entity to
run (not to exceed 16 characters, conforming to AE primitive data type),
DICOM TCP/IP port, and a numerical identifier for the application entity
(used in UID generation)

dicom-Aes.txt: file contains an entry for each known Application Entity.
Each entry consists of three words: name of the AE, TCP/IP address, and
DICOM port number respectively.

storage.txt: file holds two words: maximum number of megabytes to use for
local disk storage, and maximum number of megabytes the application program
can occupy in memory. These values directly affect the custom virtual memory
mechanisms in DCL.



Example of these files may be found in the ./dist directory in the main
source tree.



SOP Architecture



One vital point for the library client and developer is the structure of
SOP{'}s in the DCL. As previously stated, DCL makes use of compile-time
classes for the several IOD{'}s, Modules and Messages in the standard; that
is they are conventional C++ classes. However an SOP is not merely composed
of a data structure, but pertains to a set of client services which
incorporate DICOM messaging. Assuredly, SOP is a fundamental abstraction in
the whole library.



DCL SOP{'}s have a fairly simple minded organization. A class called SOPs
registers all known SOP classes, the SOPs class has an instance within the
DApplication, so features a single instance in the application. SOPs is also
a proper place to do class-wise initializations except registration for the
SOP classes.



The SOP interface is explained in the DCL Reference section, however some
elaboration is required. First of all, the SOP addresses some raw
functionality and expects a higher level construct to make use of them (such
as decoding/encoding). The actual category of such classes are DContext
descendants. Furthermore, since composite SOP classes and normalized SOP
classes represent a high level of genericity, they are handled by template
classes. One template class is defined at present: the
CompositeSOPClass<class IOD>, though a NormalizedSOPClass<\unskip\ldots> is
also required. The difference emanates from the fact that the normalized SOP
classes do not always have class and instance ID{'}s in the SOPCommon
Module.



Adjoining an SOP Class



The library purposes to support all DICOM Composite SOP classes, so addition
or removal of a class should be made effortless. The addition of an SOP
Class is realized in a few simple steps. First the programmer checks whether
the data structures have been generated. If the required module and IOD
definitions are absent, the programmer revises the relevant dictionaries,
and generates the C++ classes which go into the ./dcl-gen directory. Then,
the DCL Base Library configuration is altered so that the necessary modules
and the IOD are compiled in. Succeeding that, a declaration similar to



typedef CompositeSOPClass<CTImageIOD> CTImageStorage;



is appended to the SOPClasses.hxx interface file. Then the static members of
the SOP Class must be defined, probably in SOP.cxx file. In addition to
this, the initialization method of SOPs class must be altered so that the
new SOP Class gets registered. It might be a good idea to automate some of
this process by expanding the class generator, so that for instance the
registration routines are also automatically generated.





Getting C-GET Done



DICOM C-FIND and C-GET services demand a lot of attention whilst
implementation. These services are in fact simple query services, with the
C-FIND reporting what instances have been found, and C-GET returning
instances themselves. However, there is more to the discussion. Firstly, the
query services have a slightly alternate decoding/encoding for the
indication of keys to command the query, this combined with the wildcard and
range matching specifications make a significant burden. Secondly, and more
important than the previous issue, the information model must suit the
C-FIND/C-GET query model. The minimum implementation of the query services
demand a patient rooted hierarchical information model with a wide choice of
keys from each level of the hierarchy. The database developed for our PACS
system, indeed has a hierarchical model as required, but plenty of the keys
are missing.



The clever thing to do is to think in terms of client and server. The client
part needs a way to indicate any kind of query that can be made. This could
be over a special dataset, which goes into the query definition of the
request message. Also, the client must collect the response is composed of
multiple response messages into a simple structure and present them to the
application programmer. The server side is more elaborate, however, it seems
as though a single SQL statement construction is possible. As the keys are
interpreted, one by one, the single statement could be grown iteratively to
match the query. When, as the result of the query, instance UID{'}s of the
requested SOP instances are retrieved from the database, they can be cast
into the response. According to the type of service (the query service
C-FIND, or the retrieval service C-GET) ID{'}s or instances themselves are
emitted. The bottleneck here is the interpretation and forming of the SQL
statement. Quite elaborate handling of the query types and codings is
required, also the database must be tuned to fit the queries





Graceful DICOM Association

.

All DICOM application entities must implement the DICOM Protocol Machine.
The machine is convoluted in nature, and works by passing by PDU{'}s
according to a FSM. The establishment and closing of the association is very
important and must be tested severely, since all DICOM operations depend on
a live association. The protocol machine in DCL has been implemented in an
elegant fashion, however it has incomplete parts. For a graceful association
every possible move of the protocol machine must be handled and caressed.
Effectively, the ARTIM timers and presentation context passing is missing in
the DCL protocol machine. However, since the infrastructure is complete,
little work remains. In the case of ARTIM timers, in some events a timer
must be started, and the time-out causes the connection to close. The timers
were not required for the test purposes, so they were omitted. However
implementing the timers is not tricky. A single NT timer should be allocated
at all times, with the other timers handled via timer queue. (NT has a
limited number of timers) For presentation context implementation, only the
associate client and server methods in the DTCPContext have to be dealt
with. The associated PDU{'}s are in majority complete, and plugging in a
presentation context in the DTCPContext class must not be much of a problem.
On that occasion, the PDV list passing must also be completed to full
operation and efficiency.



Another advise would be separation of DTCPContext into a client class and a
server class. Moreover, clustering DICOM Service Groups into corresponding
classes is a good idea. Print Management has been done in that fashion.



Delicate Points



Unfortunately, the library is not at the point of perfection, so future
tasks have to be enlisted. The fleeting descriptions may not be exhaustive,
nevertheless they elucidate the crucial issues.



Modulewise operations which work at the level of an information module are
required. By these operations, one should be able to tell existence of a
module (so that the application programmer may interpret which role an
object has taken), copy, extract or move a module with the module classes.
The mutually exclusive parts of some IOD{'}s should also be considered at
this stage. The MUTEX keyword in the class generator is handled rather
awkwardly, that should be refined also. The handling of mutually exclusive
parts would make the system superlative.



Handling pointer identifiers better in IOD::add{\_}module() is suggested.
Although no conflicts arise, pointer identifiers should be checked for
collisions.



50xx and 60xx Repeating Groups are discarded altogether, for they stand as
ad hoc mechanisms in the standard. Developer should Decode/Encode Repeating
Groups appropriately, probably by putting in a flag in auto-gen Attributes
and handling of repeating groups in Transfer Syntaxes. As the standard
suggests, repeating groups are to be replaced by ordinary sequences, so the
wisest solution is to represent repeating group modules as sequences, then
while decoding/encoding perform suitable conversions.



Conditional Requirement Types are omitted currently, those types are coerced
into optional ones. Of course that should be corrected by making an
extensive condition mechanism. The most common condition is the existential,
so that must not make much of a hardship for the classgen.



For the time being, first attribute of each module is scanned, and if they
are not there, a skip flag for that module is set, which makes decoders of
that attribute optional. Collisions do not have to be handled separately
with this scheme.



The compile-time coders are a good idea, however it has little flexibility.
The current scheme disregards error recovery while parsing. On any error,
including even the slightest of protocol violations, the system comes to a
halt and throws an exception. The solution comes from enriching the
metaclass information within dataset classes. In the auto generated classes,
there is attribute information, adequate to some extent: one can dump an
attribute{'}s properties. Still and all, the information is not tied in. The
ingenious course is to write a decoder/coder method for each attribute and
relate them with static member pointers for each attribute which are,
surely, contained in a static data structure of the coder class which are in
parallel with the attribute container in the dataset class. Thereupon, the
library developer may translate some of the compile-time mechanisms to
run-time, getting a bit more freedom of action. The resulting coder is a
ephemeral algorithm which iteratively parses each attribute (in the encoding
order) from the data structures just mentioned, and handles some of the
exceptions appropriately, cushioning the application programmer from
frequent DICOM disasters.



On careful inspection of library internals, one is likely to find some flaws
with the streaming technique. There are unfortunately two methods for
streaming, one depends on some internal private routines in MFC extension,
and the other uses custom stream buffers. The stream buffer approach is more
elegant, and the former must be replaced by it. Meantime, it would be
incredibly useful to draw a base class for stream buffers and derive
specializes input and output stream classes. Despite the peaceful execution
of stream routines, these measures should be taken.





Conclusion



DCL provides graceful and effective DICOM resources to the application
programmer and empowers him with advanced tools which assist him in
comprehensible, efficient and reliable access, manipulation and operation of
DICOM images and Radiology information. Compliance to DICOM standard is
achieved by rigorous translation of standard documents into an object
oriented software system implemented in C++. DCL, while maintaining
simplicity, governs intricate issues of DICOM 3.0 standard transparently.
Since a right level of abstraction has been attained, the application
programmer needs merely a small set of public services offered by the
library in order to accomplish even the most demanding tasks. In addition to
this, the library is made flexible so adaptation of the system for future
versions of the standard is a simple contrivance.

\end{document}
